#
# Scans server config file and appends a new peer
#
# only works if all the keys are in the file
# that is, external file locations aren't resolved
#
import os
from subprocess import check_output, CalledProcessError
import ipaddress
from datetime import datetime

IFNAME = "wg0"

DEFAULT_CONF = f"/etc/wireguard/{IFNAME}.conf"

PEER_CONF_DIR = "peers"

GENMSG = f"# generated by wghelp on {datetime.now()}"

def ipv4_to_number(ipv4: str) -> int:
    parts = [int(part) for part in ipv4.split(".")]

    if any(part > 255 for part in parts):
        raise ValueError(f"invalid IPv4 address: {ipv4}")

    return sum((
        parts[0] << 24,
        parts[1] << 16,
        parts[2] << 8,
        parts[3]
    ))


def ipv6_to_number(ipv6: str) -> int:
    parts = ipv6.split(":")

    # edge case: "::"
    if all(part == "" for part in parts):
        return 0

    tmp = []
    filled = False
    for part in parts:

        # fill zeroes
        if part == "" and not filled:
            tmp.extend([0 for _ in range(8 - len(parts) + 1)])
            filled = True

            if len(tmp) == 8:
                break

        elif part == "" and filled:
            tmp.append(0)

        else:
            part_int = int(part, 16)
            if part_int > 0xffff:
                raise ValueError(f"invalid IPv6 address: {ipv6}")
            tmp.append(part_int)

    parts = tmp

    assert len(parts) == 8

    return sum((
        parts[0] << 112,
        parts[1] << 96,
        parts[2] << 80,
        parts[3] << 64,
        parts[4] << 48,
        parts[5] << 32,
        parts[6] << 16,
        parts[7]
    ))


class Peer:
    def __init__(self, allowedips):
        """
        input examples:
        AllowedIPs = 10.0.0.2/32
        AllowedIPs = 10.0.0.2/32, fd00::2/128
        Address = 10.0.0.1/24, fd00::1/64
        """
        ips = allowedips.split("=")[1].strip()

        if len(ips.split(",")) == 1:
            self.ipv4 = ips.strip().split("/")[0]
            self.ipv6 = None
        elif len(ips.split(",")) == 2:
            self.ipv4 = ips.split(",")[0].strip().split("/")[0].strip()
            self.ipv6 = ips.split(",")[1].strip().split("/")[0].strip()
        else:
            raise RuntimeError(f"I cant parse this: {allowedips}")

    def __repr__(self):
        return f"Peer: {self.ipv4} {self.ipv6}"


def scan(filename: str) -> list[Peer]:
    with open(filename, "r") as f:
        lines = f.readlines()

    peers = []

    for line in lines:
        if any((
            line.strip().lower().startswith("allowedips"),
            line.strip().lower().startswith("address")
        )):
            peers.append(Peer(line))

    return peers


def get_server_public_key(filename: str) -> str:
    with open(filename, "r") as f:
        lines = f.readlines()

    for line in lines:
        if line.strip().lower().startswith("privatekey"):
            privkey = line.split("=", 1)[1].strip()
            break

    try:
        return check_output(
            f"echo {privkey} | wg pubkey", shell=True
        ).decode().strip()
    except CalledProcessError:
        raise RuntimeError(
            f"error parsing line {line}"
        )

def get_server_port(filename: str) -> int:
    with open(filename, "r") as f:
        lines = f.readlines()
    for line in lines:
        if line.strip().lower().startswith("listenport"):
            return(int(line.split("=")[1].strip()))

def next_ipv4(peers: list[Peer]) -> str:
    ips = [ipv4_to_number(peer.ipv4) for peer in peers]
    return ipaddress.IPv4Address(max(ips) + 1).compressed

def next_ipv6(peers: list[Peer]) -> str:
    ips = [peer.ipv6 for peer in peers]
    if all((ip is None for ip in ips)):
        return None
    ips = [ipv6_to_number(ip) for ip in ips if ip is not None]
    return ipaddress.IPv6Address(max(ips) + 1).compressed


def test_functions ():
    print(ipv4_to_number("194.182.84.172"))
    print(ipv6_to_number("fe80::f816:3eff:fe8a:3430"))
    print(ipv6_to_number("fe80::"))
    print(ipv6_to_number("::"))
    print(ipv6_to_number("::ff"))

    print(Peer("AllowedIPs = 10.0.0.2/32"))
    print(Peer("AllowedIPs = 10.0.0.2/32, fd00::2/128"))
    print(Peer("Address = 10.0.0.1/24, fd00::1/64"))


def main():

    if os.name != "posix":
        print("only posix")
        exit()

    if check_output("whoami") != b"root\n":
        print("pls run as root")
        # exit()

    try:
        check_output("wg help", shell=True)
    except CalledProcessError:
        raise RuntimeError("wireguard doesn't seem to be installed")


    check_output(f"mkdir -p {PEER_CONF_DIR}", shell=True)

    filename = ""
    if os.path.isfile(DEFAULT_CONF):
        filename = DEFAULT_CONF
    else:
        print(f"{DEFAULT_CONF} doesn't exist/isn't a file")
        filename = input("specify config path: ")

    print(f"editing {filename}")

    other_peers = scan(filename)

    server_address = check_output(
        "ip route get 8.8.8.8 | head -1 | cut -d' ' -f7", shell=True
    ).decode().strip()
    server_pubkey = get_server_public_key(filename)
    server_port = get_server_port(filename)

    peer_privkey = check_output("wg genkey", shell=True).decode().strip()
    peer_pubkey = check_output(
        f"echo {peer_privkey} | wg pubkey", shell=True
    ).decode().strip()
    peer_psk = check_output("wg genpsk", shell=True).decode().strip()
    peer_ipv4 = next_ipv4(other_peers)
    peer_ipv6 = next_ipv6(other_peers)

    if peer_ipv6 is None:
        peer_allowedips = f"{peer_ipv4}/32"
    else:
        peer_allowedips = f"{peer_ipv4}/32, {peer_ipv6}/128"

    peer_conf_filename = \
        f"{PEER_CONF_DIR}/peer-{peer_ipv4.replace('.', '-')}.conf"
    with open(peer_conf_filename, "w") as f:
        f.write(f"""
{GENMSG}
[Interface]
PrivateKey = {peer_privkey}
Address = {peer_allowedips}
DNS = 193.110.81.0, 2a0f:fc80::  # dns0.eu

[Peer]
PublicKey = {server_pubkey}
PresharedKey = {peer_psk}
AllowedIPs = 0.0.0.0/0, ::/0  # tunnel both ipv4 and ipv6
Endpoint = {server_address}:{server_port}  # your wireguard server address and port
PersistentKeepalive = 25
""")

    with open(filename, "a") as f:
        f.write(f"""
{GENMSG}
[Peer]
PublicKey = {peer_pubkey}
PresharedKey = {peer_psk}
AllowedIPs = {peer_allowedips}
""")

    print("all done")
    print(f"assuming this server's ip is {server_address} and wireguard is "
          f"running on port {server_port}/udp.")
    print(f"peer adresses: {peer_allowedips}")
    print(f"peer config saved to {peer_conf_filename}")
    print(f"dont forget to")
    print(f"    systemctl restart wg-quick@{IFNAME}")


if __name__ == "__main__":
    main()
